<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `error_chain` crate."><meta name="keywords" content="rust, rustlang, rust-lang, error_chain"><title>error_chain - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate error_chain</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'error_chain', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>error_chain</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/error_chain/lib.rs.html#1-502' title='goto source code'>[src]</a></span></h1><div class='docblock'><p>A library for consistent and reliable error handling</p>
<p>This crate defines an opinionated strategy for error handling in Rust,
built on the following principles:</p>
<ul>
<li>No error should ever be discarded. This library primarily
makes it easy to &quot;chain&quot; errors with the <code>chain_err</code> method.</li>
<li>Introducing new errors is trivial. Simple errors can be introduced
at the error site with just a string.</li>
<li>Handling errors is possible with pattern matching.</li>
<li>Conversions between error types are done in an automatic and
consistent way - <code>From</code> conversion behavior is never specified
explicitly.</li>
<li>Errors implement Send.</li>
<li>Errors carry backtraces.</li>
</ul>
<p>Similar to other libraries like <a href="https://github.com/DanielKeep/rust-error-type">error-type</a> and <a href="https://github.com/tailhook/quick-error">quick-error</a>, this
library defines a macro, <code>error_chain!</code> that declares the types
and implementation boilerplate necessary for fulfilling a
particular error-hadling strategy. Most importantly it defines
a custom error type (called <code>Error</code> by convention) and the <code>From</code>
conversions that let the <code>try!</code> macro and <code>?</code> operator work.</p>
<p>This library differs in a few ways from previous error libs:</p>
<ul>
<li>Instead of defining the custom <code>Error</code> type as an enum, it is a
struct containing an <code>ErrorKind</code> (which defines the
<code>description</code> and <code>display</code> methods for the error), an opaque,
optional, boxed <code>std::error::Error + Send + 'static</code> object
(which defines the <code>cause</code>, and establishes the links in the
error chain), and a <code>Backtrace</code>.</li>
<li>The macro additionally defines a trait, by convention called
<code>ChainErr</code>, that defines a <code>chain_err</code> method. This method
on all <code>std::error::Error + Send + 'static</code> types extends
the error chain by boxing the current error into an opaque
object and putting it inside a new concrete error.</li>
<li>It provides automatic <code>From</code> conversions between other error types
defined by the <code>error_chain!</code> that preserve type information,
and facilitate seamless error composition and matching of composed
errors.</li>
<li>It provides automatic <code>From</code> conversions between any other error
type that hides the type of the other error in the <code>cause</code> box.</li>
<li>It collects a single backtrace at the earliest opportunity and
propagates it down the stack through <code>From</code> and <code>ChainErr</code>
conversions.</li>
</ul>
<p>To accomplish its goals it makes some tradeoffs:</p>
<ul>
<li>The split between the <code>Error</code> and <code>ErrorKind</code> types can make it
slightly more cumbersome to instantiate new (unchained) errors
errors, requiring an <code>Into</code> or <code>From</code> conversion; as well as
slightly more cumbersome to match on errors with another layer
of types to match.</li>
<li>Because the error type contains <code>std::error::Error + Send + 'static</code> objects,
it can't implement <code>PartialEq</code> for easy comparisons.</li>
</ul>
<h2 id="declaring-error-types" class="section-header"><a href="#declaring-error-types">Declaring error types</a></h2>
<p>Generally, you define one family of error types per crate, though
it's also perfectly fine to define error types on a finer-grained
basis, such as per module.</p>
<p>Assuming you are using crate-level error types, typically you will
define an <code>errors</code> module and inside it call <code>error_chain!</code>:</p>

<pre class="rust rust-example-rendered">
<span class="macro">error_chain</span><span class="macro">!</span> {
    <span class="comment">// The type defined for this error. These are the conventional</span>
    <span class="comment">// and recommended names, but they can be arbitrarily chosen.</span>
    <span class="ident">types</span> {
        <span class="ident">Error</span>, <span class="ident">ErrorKind</span>, <span class="ident">ChainErr</span>, <span class="prelude-ty">Result</span>;
    }

    <span class="comment">// Automatic conversions between this error chain and other</span>
    <span class="comment">// error chains. In this case, it will e.g. generate an</span>
    <span class="comment">// `ErrorKind` variant called `Dist` which in turn contains</span>
    <span class="comment">// the `rustup_dist::ErrorKind`, with conversions from</span>
    <span class="comment">// `rustup_dist::Error`.</span>
    <span class="comment">//</span>
    <span class="comment">// This section can be empty.</span>
    <span class="ident">links</span> {
        <span class="ident">rustup_dist</span>::<span class="ident">Error</span>, <span class="ident">rustup_dist</span>::<span class="ident">ErrorKind</span>, <span class="ident">Dist</span>;
        <span class="ident">rustup_utils</span>::<span class="ident">Error</span>, <span class="ident">rustup_utils</span>::<span class="ident">ErrorKind</span>, <span class="ident">Utils</span>;
    }

    <span class="comment">// Automatic conversions between this error chain and other</span>
    <span class="comment">// error types not defined by the `error_chain!`. These will be</span>
    <span class="comment">// boxed as the error cause and wrapped in a new error with,</span>
    <span class="comment">// in this case, the `ErrorKind::Temp` variant.</span>
    <span class="comment">//</span>
    <span class="comment">// This section can be empty.</span>
    <span class="ident">foreign_links</span> {
        <span class="ident">temp</span>::<span class="ident">Error</span>, <span class="ident">Temp</span>,
        <span class="string">&quot;temporary file error&quot;</span>;
    }

    <span class="comment">// Define additional `ErrorKind` variants. The syntax here is</span>
    <span class="comment">// the same as `quick_error!`, but the `from()` and `cause()`</span>
    <span class="comment">// syntax is not supported.</span>
    <span class="ident">errors</span> {
        <span class="ident">InvalidToolchainName</span>(<span class="ident">t</span>: <span class="ident">String</span>) {
            <span class="ident">description</span>(<span class="string">&quot;invalid toolchain name&quot;</span>)
            <span class="ident">display</span>(<span class="string">&quot;invalid toolchain name: &#39;{}&#39;&quot;</span>, <span class="ident">t</span>)
        }
    }
}</pre>
<p>This populates the the module with a number of definitions,
the most important of which are the <code>Error</code> type
and the <code>ErrorKind</code> type. They look something like the
following:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span> <span class="kw">as</span> <span class="ident">StdError</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">Arc</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Error</span>(<span class="kw">pub</span> <span class="ident">ErrorKind</span>,
                 <span class="kw">pub</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="ident">StdError</span> <span class="op">+</span> <span class="ident">Send</span><span class="op">&gt;&gt;</span>,
                 <span class="kw">pub</span> <span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">error_chain</span>::<span class="ident">Backtrace</span><span class="op">&gt;</span>);

<span class="kw">impl</span> <span class="ident">Error</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">kind</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">ErrorKind</span> { ... }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">into_kind</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">ErrorKind</span> { ... }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iter</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">error_chain</span>::<span class="ident">ErrorChainIter</span> { ... }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">backtrace</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">error_chain</span>::<span class="ident">Backtrace</span> { ... }
}

<span class="kw">impl</span> <span class="ident">StdError</span> <span class="kw">for</span> <span class="ident">Error</span> { ... }
<span class="kw">impl</span> <span class="ident">Display</span> <span class="kw">for</span> <span class="ident">Error</span> { ... }

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">ErrorKind</span> {
    <span class="ident">Msg</span>(<span class="ident">String</span>),
    <span class="ident">Dist</span>(<span class="ident">rustup_dist</span>::<span class="ident">ErrorKind</span>),
    <span class="ident">Utils</span>(<span class="ident">rustup_utils</span>::<span class="ident">ErrorKind</span>),
    <span class="ident">Temp</span>,
    <span class="ident">InvalidToolchainName</span>(<span class="ident">String</span>),
}</pre>
<p>This is the basic error structure. You can see that <code>ErrorKind</code>
has been populated in a variety of ways. All <code>ErrorKind</code>s get a
<code>Msg</code> variant for basic errors. When strings are converted to
<code>ErrorKind</code>s they become <code>ErrorKind::Msg</code>. The &quot;links&quot; defined in
the macro are expanded to <code>Dist</code> and <code>Utils</code> variants, and the
&quot;foreign links&quot; to the <code>Temp</code> variant.</p>
<p>Both types come with a variety of <code>From</code> conversiaos as well:
<code>Error</code> can be created from <code>ErrorKind</code>, from <code>&amp;str</code> and <code>String</code>,
and from the &quot;link&quot; and &quot;foreign_link&quot; error types. <code>ErrorKind</code>
can be created from the corresponding <code>ErrorKind</code>s of the link
types, as wall as from <code>&amp;str</code> and <code>String</code>.</p>
<p><code>into()</code> and <code>From::from</code> are used heavily to massage types into
the right shape. Which one to use in any specific case depends on
the influence of type inference, but there are some patterns that
arise frequently.</p>
<h2 id="returning-new-errors" class="section-header"><a href="#returning-new-errors">Returning new errors</a></h2>
<p>Introducing new error chains, with a string message:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Err</span>(<span class="string">&quot;foo error!&quot;</span>.<span class="ident">into</span>())
}</pre>
<p>Introducing new error chains, with an <code>ErrorKind</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Err</span>(<span class="ident">ErrorKind</span>::<span class="ident">FooError</span>.<span class="ident">into</span>())
}</pre>
<p>Note that the return type is is the typedef <code>Result</code>, which is
defined by the macro as <code>pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;</code>. Note that in both cases
<code>.into()</code> is called to convert a type into the <code>Error</code> type: both
strings and <code>ErrorKind</code> have <code>From</code> conversions to turn them into
<code>Error</code>.</p>
<p>When the error is emitted inside a <code>try!</code> macro or behind the
<code>?</code> operator, then the explicit conversion isn't needed, since
the behavior of <code>try!</code> will automatically convert <code>Err(ErrorKind)</code>
to <code>Err(Error)</code>. So the below is equivalent to the previous:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="macro">try</span><span class="macro">!</span>(<span class="prelude-val">Err</span>(<span class="ident">ErrorKind</span>::<span class="ident">FooError</span>)))
}

<span class="kw">fn</span> <span class="ident">bar</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="macro">try</span><span class="macro">!</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;bogus!&quot;</span>)))</pre>
<h2 id="chaining-errors" class="section-header"><a href="#chaining-errors">Chaining errors</a></h2>
<p>To extend the error chain:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">errors</span>::<span class="ident">ChainErr</span>;
<span class="macro">try</span><span class="macro">!</span>(<span class="ident">do_something</span>().<span class="ident">chain_err</span>(<span class="op">||</span> <span class="string">&quot;something went wrong&quot;</span>));</pre>
<p><code>chain_err</code> can be called on any <code>Result</code> type where the contained
error type implements <code>std::error::Error + Send + 'static</code>.  If
the <code>Result</code> is an <code>Err</code> then <code>chain_err</code> evaluates the closure,
which returns <em>some type that can be converted to <code>ErrorKind</code></em>,
boxes the original error to store as the cause, then returns a new
error containing the original error.</p>
<h2 id="foreign-links" class="section-header"><a href="#foreign-links">Foreign links</a></h2>
<p>Errors that do not conform to the same conventions as this library
can still be included in the error chain. They are considered &quot;foreign
errors&quot;, and are declared using the <code>foreign_links</code> block of the
<code>error_chain!</code> macro. <code>Error</code>s are automatically created from
foreign errors by the <code>try!</code> macro.</p>
<p>Foreign links and regular links have one crucial difference:
<code>From</code> conversions for regular links <em>do not introduce a new error
into the error chain</em>, while conversions for foreign links <em>always
introduce a new error into the error chain</em>. So for the example
above all errors deriving from the <code>temp::Error</code> type will be
presented to the user as a new <code>ErrorKind::Temp</code> variant, and the
cause will be the original <code>temp::Error</code> error. In contrast, when
<code>rustup_utils::Error</code> is converted to <code>Error</code> the two <code>ErrorKinds</code>
are converted between each other to create a new <code>Error</code> but the
old error is discarded; there is no &quot;cause&quot; created from the
original error.</p>
<h2 id="backtraces" class="section-header"><a href="#backtraces">Backtraces</a></h2>
<p>The earliest non-foreign error to be generated creates a single
backtrace, which is passed through all <code>From</code> conversions and
<code>chain_err</code> invocations of compatible types. To read the backtrace
just call the <code>backtrace()</code> method.</p>
<h2 id="iteration" class="section-header"><a href="#iteration">Iteration</a></h2>
<p>The <code>iter</code> method returns an iterator over the chain of error boxes.</p>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_chain.html"
                                  title='macro error_chain::error_chain'>error_chain</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.quick_error.html"
                                  title='macro error_chain::quick_error'>quick_error</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Backtrace.html"
                                  title='struct error_chain::Backtrace'>Backtrace</a></td>
                           <td class='docblock-short'>
                                <p>Representation of an owned and self-contained backtrace.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ErrorChainIter.html"
                                  title='struct error_chain::ErrorChainIter'>ErrorChainIter</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "error_chain";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>